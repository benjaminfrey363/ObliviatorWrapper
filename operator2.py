# operator2.py (New script)

import os
import subprocess
from pathlib import Path
import argparse
import time

#################################
# OBLIVIATOR OPERATOR 2 WRAPPER #
#################################

def obliviator_operator2 (
    filepath: str,
    operator2_variant: str = "default" # "default" for ~/operator_2, "opaque_shared_memory" for the other
):
    """
    Runs Obliviator's "Operator 2".

    Args:
        filepath (str): Path to the input data file (e.g., test.txt).
        operator2_variant (str): Specifies which Operator 2 implementation to use.
                                "default" for ~/obliviator/operator_2/
                                "opaque_shared_memory" for ~/obliviator/opaque_shared_memory/operator_2/
    """
    print(f"Running oblivious Operator 2 (variant: {operator2_variant}) on {filepath}")

    # Create temp directory
    temp_dir = Path("tmp_operator2") # Use a separate temp directory
    temp_dir.mkdir(exist_ok=True)
    print("Created temp directory " + str(temp_dir))

    #########################################
    # 1. Format input for Obliviator Operator 2 #
    #########################################

    # This calls format_operator2.py to preprocess the raw input file.
    # format_operator2.py will extract relevant columns and prepare
    # the data in a format suitable for relabeling (e.g., ID entire_line_after_id).
    print("Formatting input for Obliviator Operator 2...")
    format_path = temp_dir / "op2_format.txt"
    subprocess.run([
        "python", "obliviator_formatting/format_operator2.py",
        "--filepath", filepath,
        "--output_path", str(format_path)
    ], check=True, cwd=Path(__file__).parent)
    print("Formatted input written to " + str(format_path) + ".")

    ###################################################
    # 2. Relabel IDs to reduce into Obliviators range #
    ###################################################

    # Relabel the IDs generated by format_operator2.py.
    # This generates a new file with contiguous integer IDs and a mapping file.
    print("Relabeling IDs for Operator 2 input...")
    relabel_path = temp_dir / "op2_relabel.txt"
    mapping_path = temp_dir / "op2_map.txt"
    subprocess.run([
        "python", "obliviator_formatting/relabel_ids.py", # Reusing relabel_ids.py
        "--input_path", str(format_path),
        "--output_path", str(relabel_path),
        "--mapping_path", str(mapping_path)
    ], check=True, cwd=Path(__file__).parent)
    print("Relabeled input written to " + str(relabel_path) + ", relabel map written to " + str(mapping_path) + ".")

    ##############################
    # 3. Run Obliviator Operator 2 #
    ##############################

    print(f"Running Obliviator Operator 2 ({operator2_variant} variant)...")

    # Determine the correct code directory for the obliviator binary
    if operator2_variant == "default":
        code_dir = Path(os.path.expanduser("~/obliviator/operator_2"))
    elif operator2_variant == "opaque_shared_memory":
        code_dir = Path(os.path.expanduser("~/obliviator/opaque_shared_memory/operator_2"))
    else:
        raise ValueError(f"Unknown operator2_variant: {operator2_variant}. Choose 'default' or 'opaque_shared_memory'.")

    print(f"Building Obliviator Operator 2 ({operator2_variant})...")
    subprocess.run(["make", "clean"], cwd=code_dir, check=True)
    subprocess.run(["make"], cwd=code_dir, check=True)

    # Get the absolute path to the relabeled input file.
    # This path will be passed to the obliviator executable.
    absolute_path_to_input = (Path(__file__).parent / relabel_path).resolve()

    print(f"Build completed. Executing Operator 2 with input: {absolute_path_to_input} (absolute path)")
    print(f"obliviator executable will run from CWD: {code_dir}")

    # Execute Operator 2. The output is written to a file within code_dir.
    # We removed check=True for obliviator runs as it might exit non-zero on success.
    subprocess.run(
        ["./host/parallel", "./enclave/parallel_enc.signed", "1", str(absolute_path_to_input)],
        cwd=code_dir
        # check=True removed here
    )
    print("Exited Obliviator Operator 2 successfully.")

    # --- Find and Copy Obliviator's Raw Output ---
    # The output file name generated by obliviator is based on the input file's stem.
    # It writes to the SAME DIRECTORY as the input file (tmp_operator2), NOT the code_dir.
    obliviator_raw_output_filename = relabel_path.stem + "_output.txt"
    obliviator_raw_output_path_absolute = temp_dir / obliviator_raw_output_filename

    print(f"DEBUG: Expected raw Obliviator output filename: {obliviator_raw_output_filename}")
    print(f"DEBUG: Python will look for Obliviator output at: {obliviator_raw_output_path_absolute}")

    # Define the path where the raw obliviator output will be copied to within our temp directory
    obliv_op2_output_path = temp_dir / "obliv_op2_output.txt"

    try:
        # Check if the output file exists in the expected location
        if not obliviator_raw_output_path_absolute.exists():
            print(f"DEBUG: Contents of {temp_dir}: {[item.name for item in temp_dir.iterdir()]}") # Debug print
            raise FileNotFoundError(f"Obliviator output file not found: {obliviator_raw_output_path_absolute}")

        # Read content from the obliviator's raw output file
        with open(obliviator_raw_output_path_absolute, "r") as infile:
            content = infile.read()

        # Write content to our wrapper's temp output file
        with open(obliv_op2_output_path, "w") as outfile:
            outfile.write(content)
        print(f"Copied raw Obliviator output from {obliviator_raw_output_path_absolute} to {obliv_op2_output_path}.")

    except FileNotFoundError as e:
        print(f"Error: {e}")
        print("Please ensure the Obliviator Operator 2 executable correctly writes its output.")
        return # Exit the function if the file isn't found
    except Exception as e:
        print(f"An unexpected error occurred while processing Obliviator output: {e}")
        return

    ######################
    # 4. Reverse Relabel #
    ######################

    # Reverse relabel the IDs in the output.
    # The `reverse_relabel_ids.py` handles 2-column output (ID SPACE value) and 4-column output.
    # For Operator 2, the obliviator output is 4 columns, so the existing logic is suitable.
    print("Reverse-relabeling IDs for Operator 2 output...")
    final_output_path = temp_dir / "op2_output.txt"

    subprocess.run([
        "python", "obliviator_formatting/reverse_relabel_ids.py",
        "--input_path", str(obliv_op2_output_path),
        "--output_path", str(final_output_path),
        "--mapping_path", str(mapping_path)
    ], check=True, cwd=Path(__file__).parent)
    print("Reverse-relabeled Operator 2 output written to " + str(final_output_path) + ".\n\n")

    print(f"âœ… Output of Obliviator Operator 2 written to: {final_output_path}\n\n")
    return


def main():
    parser = argparse.ArgumentParser()
    # Default filepath for testing. Ensure this points to your Operator 2 test.txt
    parser.add_argument("--filepath", default="data/test_operator2.txt")
    parser.add_argument("--operator2_variant", choices=["default", "opaque_shared_memory"], default="default",
                        help="Specify the Operator 2 variant.")
    args = parser.parse_args()

    obliviator_operator2(args.filepath, args.operator2_variant)


if __name__ == "__main__":
    main()

